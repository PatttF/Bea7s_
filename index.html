<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Bea7s_</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tonejs/midi@2.0.28/build/Midi.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Flat Modern Theme */
            --bg-color: #1a202c; /* Slate 900 */
            --controls-color: #2d3748; /* Slate 800 */
            --track-header-color: #4a5568; /* Slate 700 */
            --step-off-color: #718096; /* Slate 500 */
            --primary-color: #4299e1; /* Blue 500 */
            --secondary-color: #9f7aea; /* Purple 500 */
            --step-on-color: var(--primary-color);
            --step-active-color: #ffffff;
            --text-color: #edf2f7; /* Slate 200 */
            --record-armed-color: #e53e3e; /* Red 600 */
            --danger-color: #e53e3e; /* Red 600 */
        }
        html, body {
            height: 100vh; width: 100vw; margin: 0; padding: 0;
            background-color: var(--bg-color);
            overflow: hidden;
        }
        body {
            font-family: 'Inter', sans-serif; color: var(--text-color);
            display: flex; flex-direction: column;
        }
        .main-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            padding: 0.5rem;
        }
        .sequencer-wrapper {
            flex-grow: 1;
            overflow-y: auto;
            min-height: 0;
        }
        .top-controls-wrapper {
            background-color: var(--controls-color);
            border-bottom: 1px solid #4a5568;
            padding: 0.75rem;
            flex-shrink: 0;
        }
        .bottom-controls {
            flex-shrink: 0; background-color: var(--controls-color);
            padding: 0.75rem; border-top: 1px solid #4a5568;
            transition: all 0.3s ease-in-out;
        }
        .sequencer-grid {
            display: grid;
            grid-template-columns: minmax(85px, 1.5fr) repeat(16, minmax(0, 3fr));
            gap: 4px; padding: 4px;
        }
        .step {
            transition: background-color 0.1s ease, transform 0.1s ease;
            cursor: pointer; border-radius: 4px;
            background-color: var(--step-off-color);
            border: 1px solid transparent;
        }
        .step.on {
             background-color: var(--step-on-color);
        }
        .step.ratchet-on {
            background-color: var(--secondary-color);
        }
        .step.active {
            border-color: var(--step-active-color);
            transform: scale(1.1);
        }
        .track-header {
            background-color: var(--track-header-color);
            border-radius: 4px;
        }
        .popup-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(26, 32, 44, 0.8); backdrop-filter: blur(5px);
            display: flex; justify-content: center; align-items: center; z-index: 50;
        }
        .popup {
            background-color: var(--bg-color); border: 1px solid var(--primary-color);
            border-radius: 8px; padding: 1.5rem; width: 90%; max-width: 500px;
        }
        select, button, label, input[type=text] {
            background-color: #4a5568; border: 1px solid #718096;
            border-radius: 4px; padding: 0.5rem; color: var(--text-color);
            transition: all 0.2s ease-in-out;
        }
        button:hover, label[for="load-input"]:hover, label[for="midi-file-input"]:hover {
            border-color: var(--primary-color);
            color: white;
        }
        input[type=text]:focus {
            outline: none;
            border-color: var(--primary-color);
        }
        #play-stop {
             background-color: var(--primary-color);
             border-color: var(--primary-color);
             color: white;
        }
        #record-btn.armed {
             background-color: var(--record-armed-color);
             border-color: var(--record-armed-color);
        }
        #clear-sample-btn {
            background-color: var(--danger-color);
            border-color: var(--danger-color);
        }
        .logo {
            font-weight: 700;
            color: var(--text-color);
            text-align: center;
        }
        .logo span {
            color: var(--primary-color);
        }
        .micro-step-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
        }
        .micro-step {
            width: 100%;
            padding-top: 100%;
            background-color: var(--step-off-color);
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.1s ease;
        }
        .micro-step.on {
            background-color: var(--secondary-color);
        }
    </style>
</head>
<body>
    <input type="file" id="midi-file-input" class="hidden" accept=".mid,.midi">

    <div id="loading-overlay" class="fixed inset-0 bg-slate-900 flex flex-col justify-center items-center z-[100] text-center p-4">
        <h1 class="logo text-3xl">Bea<span>7</span>s_</h1>
        <div class="mt-8 text-left max-w-md mx-auto space-y-2">
            <h2 class="text-xl font-bold text-center mb-4">How To Use</h2>
            <p><strong class="text-blue-400">Play/Stop:</strong> Use the main Play button.</p>
            <p><strong class="text-blue-400">Toggle Step:</strong> Click or drag on the grid to add/remove notes.</p>
            <p><strong class="text-blue-400">Save/Load:</strong> Use Save/Load buttons to handle MIDI files.</p>
            <p><strong class="text-blue-400">Step Options:</strong> Double-click a step for Velocity, Ratchet & Probability.</p>
            <p><strong class="text-blue-400">Track FX:</strong> Click the 'Opt' button for Pitch, Attack, Release, and other effects. Release controls Choke falloff. </p>
            <p><strong class="text-blue-400">Clear Sample:</strong> In the FX popup, clear a loaded sample.</p>
            <p><strong class="text-blue-400">Rename Track:</strong> Double-click a track name to rename it.</p>
            <p><strong class="text-blue-400">MIDI Record:</strong> Arm 'Record', then play notes on your controller.</p>
        </div>
        <p class="text-lg mt-8 mb-8">Click anywhere to start.</p>
    </div>
    
    <div class="top-controls-wrapper">
        <div class="flex flex-col gap-3 max-w-7xl mx-auto">
            <div class="flex justify-center">
                <h1 class="logo text-2xl">Bea<span>7</span>s_</h1>
            </div>
            <div class="flex items-center justify-center gap-2">
                <button id="play-stop" class="font-bold py-2 px-4 rounded-lg flex-grow">Play</button>
                <button id="record-btn" class="font-bold p-2 rounded-lg text-xs flex-grow">Record</button>
                <button id="save-midi-btn" class="font-bold p-2 rounded-lg text-xs flex-grow">Save</button>
                <button id="load-midi-btn" class="font-bold p-2 rounded-lg text-xs flex-grow">Load</button>
            </div>
            <div class="flex items-center gap-2">
                <label for="bpm" class="text-sm font-medium">BPM</label>
                <input type="range" id="bpm" min="40" max="240" value="120" class="w-full">
                <span id="bpm-value" class="font-mono w-12 text-center text-sm">120</span>
            </div>
            <div class="flex items-center justify-center flex-wrap gap-2">
                <button id="clear-btn" class="font-bold p-2 rounded-lg text-xs">Clear</button>
                <button id="mutate" class="font-bold p-2 rounded-lg text-xs">Mutate</button>
                <button id="beat-repeat-btn" class="font-bold p-2 rounded-lg text-xs">Repeat</button>
                <button id="midi-toggle-btn" class="font-bold p-2 rounded-lg text-xs">MIDI</button>
            </div>
        </div>
    </div>

    <div class="main-container w-full">
        <div class="sequencer-wrapper">
            <div id="sequencer-grid" class="sequencer-grid"></div>
        </div>
    </div>
    
    <div id="bottom-controls" class="bottom-controls hidden">
        <div class="grid grid-cols-2 gap-4 max-w-md mx-auto">
             <div class="control-group flex flex-col"><label class="text-xs" for="midi-input-device">MIDI In Device</label><select id="midi-input-device" class="w-full text-sm"></select></div>
             <div class="control-group flex flex-col"><label class="text-xs" for="midi-input-channel">MIDI In Ch</label><select id="midi-input-channel" class="w-full text-sm"></select></div>
        </div>
    </div>

    <div id="track-popup" class="popup-overlay hidden"></div>
    <div id="step-popup" class="popup-overlay hidden"></div>
    
    <div id="save-modal" class="popup-overlay hidden">
        <div class="popup">
            <h2 class="text-2xl font-bold mb-4">Save MIDI File</h2>
            <div class="space-y-2">
                <label for="filename-input">Filename</label>
                <input type="text" id="filename-input" class="w-full" placeholder="bea7s-pattern">
            </div>
            <div class="mt-6 flex gap-4">
                <button id="cancel-save-btn" class="font-bold py-2 px-4 rounded-lg flex-grow">Cancel</button>
                <button id="confirm-save-btn" class="font-bold py-2 px-4 rounded-lg flex-grow bg-blue-500">Save</button>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const NUM_STEPS = 16;
            const NUM_TRACKS = 12;
            let trackNames = ['Kick', 'Snare', 'Clap', 'Closed Hat', 'Open Hat', 'Low Tom', 'Mid Tom', 'High Tom', 'Crash', 'Cowbell', 'Claves', 'Maracas'];
            
            const trackNotes = [36, 38, 39, 42, 46, 45, 48, 50, 49, 56, 75, 70];
            const noteMap = {
                35: 0, 36: 0, 38: 1, 40: 1, 39: 2, 42: 3, 44: 3, 46: 4, 41: 5, 43: 5, 45: 5, 47: 6, 48: 6, 50: 7,
                49: 8, 52: 8, 55: 8, 57: 8, 56: 9, 75: 10, 70: 11
            };

            let sequenceData = [];
            let instruments = [];
            let currentStep = 0;
            let midiAccess = null;
            let activeMIDIInputId = null;
            let beatRepeatActive = false;
            let repeatEventId = null;
            let activePopupTrack = -1;
            let activeStepForPopup = { track: -1, step: -1 };
            let recordArmed = false;
            let isDrawing = false;
            let drawMode = null; 

            const allElements = {
                loadingOverlay: document.getElementById('loading-overlay'),
                sequencerGrid: document.getElementById('sequencer-grid'),
                playStopBtn: document.getElementById('play-stop'),
                bpmSlider: document.getElementById('bpm'),
                bpmValue: document.getElementById('bpm-value'),
                mutateBtn: document.getElementById('mutate'),
                beatRepeatBtn: document.getElementById('beat-repeat-btn'),
                recordBtn: document.getElementById('record-btn'),
                clearBtn: document.getElementById('clear-btn'),
                midiToggleBtn: document.getElementById('midi-toggle-btn'),
                bottomControls: document.getElementById('bottom-controls'),
                midiInputDevice: document.getElementById('midi-input-device'),
                midiInputChannel: document.getElementById('midi-input-channel'),
                trackPopup: document.getElementById('track-popup'),
                stepPopup: document.getElementById('step-popup'),
                saveMidiBtn: document.getElementById('save-midi-btn'),
                loadMidiBtn: document.getElementById('load-midi-btn'),
                midiFileInput: document.getElementById('midi-file-input'),
                saveModal: document.getElementById('save-modal'),
                filenameInput: document.getElementById('filename-input'),
                confirmSaveBtn: document.getElementById('confirm-save-btn'),
                cancelSaveBtn: document.getElementById('cancel-save-btn'),
            };

            function createPopupHTML() {
                 allElements.trackPopup.innerHTML = `<div class="popup"><h2 id="popup-track-name" class="text-2xl font-bold mb-4"></h2><div id="custom-synth-controls-container" class="space-y-4 mb-4"></div> <hr class="my-4 border-gray-600"> <div id="generic-controls-container" class="space-y-4"><div><label>Volume</label><input type="range" id="volume" min="-40" max="6" value="0" step="1"></div><div><label>Pan</label><input type="range" id="pan" min="-1" max="1" value="0" step="0.1"></div><div><label>Reverb</label><input type="range" id="reverb" min="0" max="1" value="0" step="0.01"></div><div><label>Delay</label><input type="range" id="delay" min="0" max="1" value="0" step="0.01"></div><div><label>Attack</label><input type="range" id="attack" min="0" max="1" value="0" step="0.01"></div><div><label>Release</label><input type="range" id="release" min="0.01" max="2" value="0.1" step="0.01"></div><div id="choke-group-container"><label>Choke Group</label><select id="choke-group" class="w-full"></select></div></div><div id="popup-actions" class="mt-6 flex gap-4"></div></div>`;
                 allElements.stepPopup.innerHTML = `<div class="popup"><h2 class="text-2xl font-bold mb-4">Step Options</h2><div class="space-y-4"><div><label for="velocity">Velocity</label><input type="range" id="velocity" min="0.1" max="1" value="1" step="0.01"></div><div class="space-y-2"><label>Ratchet</label><div class="w-1/2"><div id="ratchet-grid" class="micro-step-grid"></div></div></div><div class="space-y-2"><div class="flex justify-between items-center"><label for="probability">Probability</label><span id="probability-value" class="font-mono text-sm">100%</span></div><input type="range" id="probability" min="0" max="100" value="100" step="1"></div></div><button id="close-step-popup" class="mt-6 w-full text-lg">Close</button></div>`;
            }

            function createDefaultSynth(index) {
                let synth, type, attack, release;
                switch(index) {
                    case 0: attack = 0.002; release = 0.4; synth = new Tone.MembraneSynth({ pitchDecay: 0.04, octaves: 6, oscillator: { type: "sine" }, envelope: { attack, decay: 0.8, sustain: 0.01, release } }); type = 'kick'; break;
                    case 1: attack = 0.001; release = 0.2; synth = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.005, decay: 0.2, sustain: 0, release: 0.1 }}); type = 'snare'; break;
                    case 2: attack = 0.001; release = 0.1; synth = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack, decay: 0.1, sustain: 0, release: 0.1 } }); type = 'clap'; break;
                    case 3: attack = 0.001; release = 0.05; synth = new Tone.MetalSynth({ frequency: 400, envelope: { attack, decay: 0.05, release }, harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5 }); type = 'hihat'; break;
                    case 4: attack = 0.001; release = 0.5; synth = new Tone.MetalSynth({ frequency: 250, envelope: { attack, decay: 0.08, release }, harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5 }); type = 'hihat'; break;
                    case 5: attack = 0.01; release = 0.4; synth = new Tone.MembraneSynth({ pitchDecay: 0.08, octaves: 4, oscillator: { type: "sine" }, envelope: { attack, decay: 0.3, sustain: 0.01, release } }); type = 'tom'; break;
                    case 6: attack = 0.01; release = 0.4; synth = new Tone.MembraneSynth({ pitchDecay: 0.06, octaves: 5, oscillator: { type: "sine" }, envelope: { attack, decay: 0.3, sustain: 0.01, release } }); type = 'tom'; break;
                    case 7: attack = 0.01; release = 0.4; synth = new Tone.MembraneSynth({ pitchDecay: 0.04, octaves: 6, oscillator: { type: "sine" }, envelope: { attack, decay: 0.2, sustain: 0.01, release } }); type = 'tom'; break;
                    case 8: attack = 0.01; release = 1.5; synth = new Tone.MetalSynth({ frequency: 200, envelope: { attack, decay: 1, release }, harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 3 }); type = 'cymbal'; break;
                    default: attack = 0.001; release = 0.2; synth = new Tone.PluckSynth({ attackNoise: 1, dampening: 4000, resonance: 0.9, release }); type = 'generic_perc'; break;
                }
                return { synth, type, attack, release };
            }
            
            function setupInstruments() {
                const globalReverb = new Tone.Reverb(1.5).toDestination();
                const globalDelay = new Tone.FeedbackDelay("8n", 0.5).toDestination();
                
                for(let i=0; i < NUM_TRACKS; i++) {
                    const panVol = new Tone.PanVol(0, 0).toDestination();
                    const reverbSend = new Tone.Gain(0).connect(globalReverb);
                    const delaySend = new Tone.Gain(0).connect(globalDelay);
                   
                    const fxChain = { panVol, reverbSend, delaySend };
                    let chokeGroup = (i === 3 || i === 4) ? 1 : 0; 

                    const { synth, type, attack, release } = createDefaultSynth(i);
                    synth.connect(fxChain.panVol);
                    synth.connect(fxChain.reverbSend);
                    synth.connect(fxChain.delaySend);

                    instruments[i] = { name: trackNames[i], synth, fx: fxChain, player: null, source: synth, type, attack, release, playbackRate: 1, chokeGroup };
                }
            }
            
            function createSequencerGrid() {
                allElements.sequencerGrid.innerHTML = '';
                for (let t = 0; t < NUM_TRACKS; t++) {
                    sequenceData[t] = [];
                    const header = document.createElement('div');
                    header.className = 'track-header flex flex-col items-center justify-center p-1 rounded text-center';
                    header.dataset.track = t;
                    header.innerHTML = `<span data-track="${t}" class="track-name font-bold truncate cursor-pointer">${trackNames[t]}</span><div class="flex gap-1 mt-1"><button data-track="${t}" class="settings-btn text-xs p-1">Opt</button><input type="file" id="track-${t}-loader" class="hidden" accept=".wav"><label for="track-${t}-loader" class="text-xs p-1 cursor-pointer">Load</label></div>`;
                    allElements.sequencerGrid.appendChild(header);
                    for (let s = 0; s < NUM_STEPS; s++) {
                        sequenceData[t][s] = { on: false, velocity: 1, ratchet: [true, false, false, false], probability: 1 };
                        const e = document.createElement('div');
                        e.className = 'step'; e.dataset.track = t; e.dataset.step = s;
                        allElements.sequencerGrid.appendChild(e);
                    }
                }
            }
            
            function triggerStep(step, time, velocityFromMIDI = null) {
                if (step === -1) return; 

                for (let track = 0; track < NUM_TRACKS; track++) {
                    const stepData = sequenceData[track][step];
                    if (stepData.on && (velocityFromMIDI !== null || Math.random() < stepData.probability)) {
                        const triggerVelocity = velocityFromMIDI !== null ? velocityFromMIDI : stepData.velocity;
                        const instrument = instruments[track];
                        const { source, type, chokeGroup } = instrument;
                        
                        if (chokeGroup > 0) {
                            instruments.forEach((otherInst, otherIdx) => {
                                if (track !== otherIdx && otherInst.chokeGroup === chokeGroup && otherInst.source) {
                                    if (otherInst.source instanceof Tone.Player) {
                                        otherInst.source.stop(time);
                                    } else {
                                        otherInst.source.triggerRelease(time);
                                    }
                                }
                            });
                        }

                        const note = getNoteForTrack(track);
                        const microStepDuration = Tone.Time('16n').toSeconds() / 4;

                        stepData.ratchet.forEach((isOn, index) => {
                            if (isOn) {
                                const ratchetTime = time + index * microStepDuration;
                                if (source instanceof Tone.Player) {
                                    source.start(ratchetTime, 0, undefined, triggerVelocity);
                                } else if (type === 'snare' || type === 'clap') {
                                    source.triggerAttackRelease(instrument.release, ratchetTime, triggerVelocity);
                                } else {
                                    source.triggerAttackRelease(note, microStepDuration * 0.9, ratchetTime, triggerVelocity);
                                }
                            }
                        });
                    }
                }
            }
            
            function handleGridDblClick(e) {
                if (e.target.classList.contains('track-name')) { renameTrack(e.target); } 
                else if (e.target.classList.contains('step')) { openStepPopup(parseInt(e.target.dataset.track), parseInt(e.target.dataset.step)); }
            }
            
            function handleGridClick(e) {
                const target = e.target;
                if (target.classList.contains('settings-btn')) { 
                    openTrackPopup(parseInt(target.dataset.track)); 
                } else if (target.tagName === 'LABEL' && target.htmlFor.includes('loader')) {
                    document.getElementById(target.htmlFor).addEventListener('change', (ev) => loadSample(parseInt(target.htmlFor.split('-')[1]), ev.target.files[0]), { once: true });
                }
            }

            function renameTrack(spanElement) {
                const track = parseInt(spanElement.dataset.track);
                const input = document.createElement('input');
                input.type = 'text'; input.value = spanElement.textContent;
                input.className = 'bg-gray-700 text-white w-full text-xs text-center';
                spanElement.replaceWith(input); input.focus();
                const save = () => {
                    const newName = input.value.trim();
                    if (newName) { trackNames[track] = newName; }
                    spanElement.textContent = trackNames[track];
                    input.replaceWith(spanElement);
                };
                input.addEventListener('blur', save);
                input.addEventListener('keydown', e => { if(e.key === 'Enter') save(); });
            }
            
            function startBeatRepeat() {
                if (beatRepeatActive || Tone.Transport.state !== 'started') return;
                beatRepeatActive = true;
                const beatRepeatLength = 4;
                Tone.Transport.cancel(); 
                const startStep = Math.floor(currentStep / beatRepeatLength) * beatRepeatLength;
                let repeatSteps = Array.from({length: beatRepeatLength}, (_, i) => (startStep + i) % NUM_STEPS);
                repeatEventId = new Tone.Sequence((time, step) => {
                    triggerStep(step, time);
                    Tone.Draw.schedule(() => updateActiveStepUI(step), time);
                }, repeatSteps, "16n").start(0);
            }

            function stopBeatRepeat() {
                if (!beatRepeatActive) return;
                beatRepeatActive = false;
                if (repeatEventId) { repeatEventId.dispose(); repeatEventId = null; }
                Tone.Transport.cancel();
                Tone.Transport.scheduleRepeat(onStep, '16n');
            }
            
            function toggleRecord() {
                recordArmed = !recordArmed;
                allElements.recordBtn.classList.toggle('armed', recordArmed);
            }
            
            function getNoteForTrack(t) { return Tone.Frequency(trackNotes[t], "midi").toNote() }
            function updateActiveStepUI(s) { document.querySelectorAll('.step').forEach(e => e.classList.remove('active')); if (s > -1) document.querySelectorAll(`.step[data-step='${s}']`).forEach(e => e.classList.add('active')); }
            
            async function setupMIDI() {
                if (!navigator.requestMIDIAccess) return;
                try {
                    midiAccess = await navigator.requestMIDIAccess();
                    populateMIDIDevices();
                    midiAccess.onstatechange = populateMIDIDevices;
                } catch (e) {
                    console.error("MIDI Error:", e);
                }
            }

            function populateMIDIDevices() {
                allElements.midiInputDevice.innerHTML = '<option value="">None</option>';
                midiAccess.inputs.forEach(i => {
                    const o = new Option(i.name, i.id, false, i.id === activeMIDIInputId);
                    allElements.midiInputDevice.add(o);
                    i.onmidimessage = onMIDIMessage;
                });
                
                if (allElements.midiInputChannel.options.length <= 1) {
                    allElements.midiInputChannel.innerHTML = '<option value="0">All</option>';
                    for (let i = 1; i <= 16; i++) {
                        allElements.midiInputChannel.add(new Option(i, i));
                    }
                    allElements.midiInputChannel.value = "10";
                }
            }
            
            function onMIDIMessage(e) {
                if (e.target.id !== activeMIDIInputId) return;
                const [command, note, velocity] = e.data;
                const channel = (command & 0x0f) + 1;
                const cmd = command >> 4;
                const selectedChannel = parseInt(allElements.midiInputChannel.value);
                if (selectedChannel !== 0 && channel !== selectedChannel) return;
                const trackIndex = noteMap[note];
                if (trackIndex === undefined) return;

                if (cmd === 9 && velocity > 0) {
                    const toneVelocity = velocity / 127;
                    if (recordArmed && Tone.Transport.state === 'started') {
                        const ticksPerStep = Tone.Transport.PPQ / 4;
                        const recordStep = Math.floor(Tone.Transport.ticks / ticksPerStep) % NUM_STEPS;
                        const stepData = sequenceData[trackIndex][recordStep];
                        stepData.on = true;
                        stepData.velocity = toneVelocity;
                        stepData.ratchet = [true, false, false, false];
                        stepData.probability = 1;
                        redrawGridFromData();
                    }
                    const { source, type, release } = instruments[trackIndex];
                    const noteName = getNoteForTrack(trackIndex);
                    if (source instanceof Tone.Player) {
                        source.start(Tone.now(), 0, undefined, toneVelocity);
                    } else if (type === 'snare' || type === 'clap') {
                        source.triggerAttackRelease(release, Tone.now(), toneVelocity);
                    }
                    else {
                        source.triggerAttackRelease(noteName, '16n', Tone.now(), toneVelocity);
                    }
                }
            }
            
            function togglePlayback() { if ("started" === Tone.Transport.state) { Tone.Transport.stop(); allElements.playStopBtn.textContent = 'Play'; currentStep = 0; updateActiveStepUI(-1); } else { Tone.Transport.start(); allElements.playStopBtn.textContent = 'Stop'; } }
            
            function toggleStep(t, s) {
                const stepData = sequenceData[t][s];
                stepData.on = !stepData.on;
                redrawGridFromData();
            }
            
            async function loadSample(trackIndex, file) {
                if (!file) return;
                const url = URL.createObjectURL(file);
                const instrument = instruments[trackIndex];

                if (instrument.player) instrument.player.dispose();
                if (instrument.synth) {
                    instrument.synth.dispose();
                    instrument.synth = null;
                }
                
                instrument.attack = 0; 
                instrument.release = 1;
                instrument.playbackRate = 1;

                const player = new Tone.Player(url);
                player.retrigger = true;
                player.fadeIn = instrument.attack;
                player.fadeOut = instrument.release;
                player.playbackRate.value = instrument.playbackRate;
                
                player.connect(instrument.fx.panVol);
                player.connect(instrument.fx.reverbSend);
                player.connect(instrument.fx.delaySend);

                await Tone.loaded(); 

                instrument.player = player;
                instrument.source = player;
                
                document.querySelector(`.track-header[data-track='${trackIndex}'] .track-name`)?.classList.add('text-blue-400');
            }
            
            function mutateSequence() { for (let t = 0; t < NUM_TRACKS; t++) for (let s = 0; s < NUM_STEPS; s++) if (Math.random() < .25) toggleStep(t, s); }
            
            function clearSequence() {
                 for (let t = 0; t < NUM_TRACKS; t++) for (let s = 0; s < NUM_STEPS; s++) {
                    sequenceData[t][s] = { on: false, velocity: 1, ratchet: [true, false, false, false], probability: 1 };
                }
                redrawGridFromData();
            }

            function redrawGridFromData() {
                 for (let t = 0; t < NUM_TRACKS; t++) for (let s = 0; s < NUM_STEPS; s++) {
                    const stepEl = allElements.sequencerGrid.querySelector(`.step[data-track='${t}'][data-step='${s}']`);
                    const stepData = sequenceData[t][s];
                    if (stepEl) {
                       stepEl.classList.toggle('on', stepData.on);
                       const activeMicroSteps = stepData.ratchet.filter(Boolean).length;
                       stepEl.classList.toggle('ratchet-on', activeMicroSteps > 1 && stepData.on);
                    }
                }
            }
            
            function saveMIDI(filename) {
                const midi = new Midi();
                midi.header.setTempo(Tone.Transport.bpm.value);
                const track = midi.addTrack();
                track.channel = 9; 
                track.name = "Bea7s_ Drums";

                for (let step = 0; step < NUM_STEPS; step++) {
                    for (let trackIndex = 0; trackIndex < NUM_TRACKS; trackIndex++) {
                        const stepData = sequenceData[trackIndex][step];
                        if (stepData.on) {
                             const microStepDuration = Tone.Time('16n').toSeconds() / 4;
                             stepData.ratchet.forEach((isOn, rIndex) => {
                                 if (isOn) {
                                     track.addNote({
                                         midi: trackNotes[trackIndex],
                                         time: (step * (microStepDuration*4)) + (rIndex * microStepDuration),
                                         duration: microStepDuration,
                                         velocity: stepData.velocity,
                                     });
                                 }
                             });
                        }
                    }
                }

                const bytes = midi.toArray();
                const blob = new Blob([bytes], { type: 'audio/midi' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${filename}.mid`;
                a.click();
                URL.revokeObjectURL(url);
            }
            
            function loadMIDI(e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const midi = new Midi(event.target.result);
                        clearSequence();

                        if (midi.header.tempos.length > 0) {
                            const newBpm = midi.header.tempos[0].bpm;
                            allElements.bpmSlider.value = newBpm;
                            allElements.bpmValue.textContent = newBpm;
                            Tone.Transport.bpm.value = newBpm;
                        }

                        const stepDuration = Tone.Time('16n').toSeconds();

                        midi.tracks.forEach(track => {
                            if (track.channel === 9) {
                                track.notes.forEach(note => {
                                    const appTrackIndex = noteMap[note.midi];
                                    if (appTrackIndex !== undefined) {
                                        const stepIndex = Math.floor(note.time / stepDuration);
                                        // FIXED: Corrected syntax error
                                        if (stepIndex >= 0 && stepIndex < NUM_STEPS) {
                                            const stepData = sequenceData[appTrackIndex][stepIndex];
                                            if (!stepData.on) {
                                                stepData.on = true;
                                                stepData.velocity = note.velocity;
                                                stepData.probability = 1;
                                                stepData.ratchet = [false, false, false, false];
                                            }
                                            const microStepIndex = Math.round((note.time % stepDuration) / (stepDuration / 4));
                                            if(microStepIndex < 4) stepData.ratchet[microStepIndex] = true;
                                        }
                                    }
                                });
                            }
                        });
                        redrawGridFromData();
                    } catch (err) {
                        console.error("Error parsing MIDI file:", err);
                    }
                };
                reader.readAsArrayBuffer(file);
                e.target.value = '';
            }
            
            function clearSample(trackIndex) {
                const instrument = instruments[trackIndex];
                if (instrument.player) {
                    instrument.player.dispose();
                    instrument.player = null;
                }

                const { synth, type, attack, release } = createDefaultSynth(trackIndex);
                const fxChain = instrument.fx;
                
                instrument.attack = attack;
                instrument.release = release;
                instrument.playbackRate = 1;
                
                synth.set({ envelope: { attack: instrument.attack, release: instrument.release } });

                synth.connect(fxChain.panVol);
                synth.connect(fxChain.reverbSend);
                synth.connect(fxChain.delaySend);

                instrument.synth = synth;
                instrument.source = synth;
                instrument.type = type;

                document.querySelector(`.track-header[data-track='${trackIndex}'] .track-name`)?.classList.remove('text-blue-400');
                
                if (activePopupTrack === trackIndex) {
                    openTrackPopup(trackIndex);
                }
            }
            
            function openTrackPopup(trackIndex) {
                activePopupTrack = trackIndex;
                const instrument = instruments[trackIndex];
                if (!instrument) return;

                const popup = allElements.trackPopup;
                popup.querySelector("#popup-track-name").textContent = `Track: ${trackNames[trackIndex]}`;
                const customControlsContainer = popup.querySelector("#custom-synth-controls-container");
                const genericControlsContainer = popup.querySelector("#generic-controls-container");
                const actionsContainer = popup.querySelector("#popup-actions");
                customControlsContainer.innerHTML = '';
                actionsContainer.innerHTML = '';
                
                const existingPitchControl = genericControlsContainer.querySelector("#pitch-control");
                if (existingPitchControl) existingPitchControl.remove();
                
                const chokeSelect = popup.querySelector("#choke-group");
                chokeSelect.innerHTML = '<option value="0">None</option>';
                for(let i=1; i<=12; i++) {
                    chokeSelect.add(new Option(`Group ${i}`, i));
                }
                chokeSelect.value = instrument.chokeGroup;


                let controlsHTML = '';
                
                if(instrument.player){
                    const pitchControlHTML = `<div id="pitch-control"><label>Pitch</label><input type="range" id="pitch" min="0.25" max="4" value="${instrument.playbackRate}" step="0.01"></div>`;
                    customControlsContainer.insertAdjacentHTML('beforeend', pitchControlHTML);
                    actionsContainer.innerHTML = `<button id="clear-sample-btn" data-track="${trackIndex}" class="font-bold py-2 px-4 rounded-lg flex-grow">Clear Sample</button>`;
                } else if (instrument.synth) {
                    const currentSynthSettings = instrument.synth.get();
                    switch (instrument.type) {
                        case 'snare':
                        case 'clap':
                            controlsHTML = `<div><label>Decay</label><input type="range" data-param="release" min="0.01" max="1" value="${instrument.release}" step="0.01"></div>`;
                             break;
                        case 'kick':
                        case 'tom':
                            controlsHTML = `<div><label>Pitch Decay</label><input type="range" data-param="pitchDecay" min="0.01" max="0.5" value="${currentSynthSettings.pitchDecay}" step="0.01"></div>`;
                            break;
                        case 'hihat':
                        case 'cymbal':
                             controlsHTML = `<div><label>Metallic</label><input type="range" data-param="harmonicity" min="1" max="10" value="${currentSynthSettings.harmonicity}" step="0.1"></div><div><label>Resonance</label><input type="range" data-param="resonance" min="1000" max="8000" value="${currentSynthSettings.resonance}" step="100"></div>`;
                            break;
                    }
                }
                
                customControlsContainer.innerHTML = controlsHTML;
                actionsContainer.innerHTML += `<button id="close-popup" class="font-bold py-2 px-4 rounded-lg flex-grow">Close</button>`;

                popup.querySelector("#volume").value = instrument.fx.panVol.volume.value;
                popup.querySelector("#pan").value = instrument.fx.panVol.pan.value;
                popup.querySelector("#reverb").value = instrument.fx.reverbSend.gain.value;
                popup.querySelector("#delay").value = instrument.fx.delaySend.gain.value;
                popup.querySelector("#attack").value = instrument.attack;
                popup.querySelector("#release").value = instrument.release;
                
                popup.classList.remove("hidden");
            }
            
            function closeTrackPopup() { allElements.trackPopup.classList.add("hidden"); activePopupTrack = -1; }
            
            function openStepPopup(t, s) {
                activeStepForPopup = { track: t, step: s };
                const stepData = sequenceData[t][s];
                const popup = allElements.stepPopup;

                popup.querySelector("#velocity").value = stepData.velocity;
                popup.querySelector("#probability").value = stepData.probability * 100;
                popup.querySelector("#probability-value").textContent = `${Math.round(stepData.probability * 100)}%`;

                const ratchetGrid = popup.querySelector("#ratchet-grid");
                ratchetGrid.innerHTML = '';
                for (let i = 0; i < 4; i++) {
                    const microStep = document.createElement('div');
                    microStep.className = 'micro-step';
                    microStep.dataset.index = i;
                    if (stepData.ratchet[i]) {
                        microStep.classList.add('on');
                    }
                    ratchetGrid.appendChild(microStep);
                }
                popup.classList.remove("hidden");
            }
            
            function closeStepPopup() { allElements.stepPopup.classList.add("hidden"); activeStepForPopup = { track: -1, step: -1 }; redrawGridFromData(); }
            
            function openSaveModal() {
                allElements.saveModal.classList.remove('hidden');
                allElements.filenameInput.focus();
            }

            function closeSaveModal() {
                allElements.saveModal.classList.add('hidden');
            }
            
            function setupPopupControls() {
                allElements.trackPopup.addEventListener('input', e => {
                    if (activePopupTrack < 0) return;
                    const instrument = instruments[activePopupTrack];
                    const param = e.target.dataset.param;
                    const value = parseFloat(e.target.value);
                    if (e.target.id === 'volume') { instrument.fx.panVol.volume.value = value; }
                    else if (e.target.id === 'pan') { instrument.fx.panVol.pan.value = value; }
                    else if (e.target.id === 'reverb') { instrument.fx.reverbSend.gain.value = value; }
                    else if (e.target.id === 'delay') { instrument.fx.delaySend.gain.value = value; }
                    else if (e.target.id === 'attack') {
                        instrument.attack = value;
                        if (instrument.player) instrument.player.fadeIn = value;
                        else if (instrument.synth.envelope) instrument.synth.set({ envelope: { attack: value } });
                    }
                    else if (e.target.id === 'release') {
                        instrument.release = value;
                        if (instrument.player) instrument.player.fadeOut = value;
                        else if (instrument.synth.envelope) instrument.synth.set({ envelope: { release: value } });
                    }
                    else if (e.target.id === 'pitch') {
                        instrument.playbackRate = value;
                        if (instrument.player) instrument.player.playbackRate.value = value;
                    }
                    else if (e.target.id === 'choke-group') {
                        instrument.chokeGroup = parseInt(e.target.value, 10);
                    }
                    else if(param && !(instrument.source instanceof Tone.Player) && instrument.synth) {
                       if (instrument.synth.get(param) !== undefined) {
                            instrument.synth.set({ [param]: value });
                       } else if (instrument.synth.envelope && instrument.synth.get().envelope[param] !== undefined) {
                            instrument.synth.set({ envelope: { [param]: value } });
                       }
                    }
                });

                allElements.trackPopup.addEventListener('click', e => {
                    if (e.target.id === 'close-popup') {
                        closeTrackPopup();
                    } else if (e.target.id === 'clear-sample-btn') {
                        const trackIndex = parseInt(e.target.dataset.track);
                        clearSample(trackIndex);
                    }
                });

                allElements.stepPopup.addEventListener('input', e => {
                    const { track: t, step: s } = activeStepForPopup;
                    if (t < 0) return;
                    const stepData = sequenceData[t][s];
                    
                    if (e.target.id === 'velocity') {
                        stepData.velocity = parseFloat(e.target.value);
                    } else if (e.target.id === 'probability') {
                        const probValue = parseInt(e.target.value, 10);
                        stepData.probability = probValue / 100;
                        allElements.stepPopup.querySelector("#probability-value").textContent = `${probValue}%`;
                    }
                });

                allElements.stepPopup.addEventListener('click', e => {
                    if(e.target.classList.contains('micro-step')) {
                        const { track: t, step: s } = activeStepForPopup;
                        if (t < 0) return;
                        
                        const index = parseInt(e.target.dataset.index, 10);
                        const stepData = sequenceData[t][s];
                        stepData.ratchet[index] = !stepData.ratchet[index];
                        e.target.classList.toggle('on');
                    }
                });
            }

            function onStep(time) {
                const stepToPlay = currentStep;
                triggerStep(stepToPlay, time);
                Tone.Draw.schedule(() => updateActiveStepUI(stepToPlay), time);
                currentStep = (currentStep + 1) % NUM_STEPS;
            }

            function setupEventListeners() {
                allElements.playStopBtn.addEventListener('click', togglePlayback);
                allElements.bpmSlider.addEventListener('input', (e) => { Tone.Transport.bpm.value = e.target.value; allElements.bpmValue.textContent = e.target.value; });
                allElements.sequencerGrid.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('step')) {
                        isDrawing = true;
                        const stepData = sequenceData[e.target.dataset.track][e.target.dataset.step];
                        drawMode = stepData.on ? 'remove' : 'add';
                        toggleStep(parseInt(e.target.dataset.track), parseInt(e.target.dataset.step));
                    }
                });

                allElements.sequencerGrid.addEventListener('mouseover', (e) => {
                    if (isDrawing && e.target.classList.contains('step')) {
                        const track = parseInt(e.target.dataset.track);
                        const step = parseInt(e.target.dataset.step);
                        const stepData = sequenceData[track][step];
                        
                        if (drawMode === 'add' && !stepData.on) {
                            toggleStep(track, step);
                        } else if (drawMode === 'remove' && stepData.on) {
                            toggleStep(track, step);
                        }
                    }
                });
                
                document.body.addEventListener('mouseup', () => {
                    isDrawing = false;
                    drawMode = null;
                });
                
                allElements.sequencerGrid.addEventListener('click', handleGridClick);
                allElements.sequencerGrid.addEventListener('dblclick', handleGridDblClick);
                allElements.mutateBtn.addEventListener('click', mutateSequence);
                allElements.midiInputDevice.addEventListener('change', (e) => activeMIDIInputId = e.target.value);
                allElements.beatRepeatBtn.addEventListener('mousedown', startBeatRepeat);
                allElements.beatRepeatBtn.addEventListener('mouseup', stopBeatRepeat);
                allElements.beatRepeatBtn.addEventListener('mouseleave', stopBeatRepeat);
                allElements.beatRepeatBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startBeatRepeat(); });
                allElements.beatRepeatBtn.addEventListener('touchend', (e) => { e.preventDefault(); stopBeatRepeat(); });
                allElements.recordBtn.addEventListener('click', toggleRecord);
                allElements.clearBtn.addEventListener('click', clearSequence);
                allElements.midiToggleBtn.addEventListener('click', () => { allElements.bottomControls.classList.toggle('hidden'); });
                allElements.stepPopup.querySelector('#close-step-popup').addEventListener('click', closeStepPopup);
                
                allElements.saveMidiBtn.addEventListener('click', openSaveModal);
                allElements.loadMidiBtn.addEventListener('click', () => allElements.midiFileInput.click());
                allElements.midiFileInput.addEventListener('change', loadMIDI);
                
                allElements.confirmSaveBtn.addEventListener('click', () => {
                    const filename = allElements.filenameInput.value || `bea7s-pattern-${Date.now()}`;
                    saveMIDI(filename);
                    closeSaveModal();
                });
                allElements.cancelSaveBtn.addEventListener('click', closeSaveModal);

                setupPopupControls();
            }

            async function initialize() {
                // FIXED: Reordered initialization sequence
                createPopupHTML();
                setupInstruments();
                createSequencerGrid();
                setupEventListeners();
                await setupMIDI();
                
                await Tone.start();
                console.log("AudioContext started");
                
                Tone.Transport.bpm.value = 120;
                Tone.Transport.scheduleRepeat(onStep, '16n');
                allElements.loadingOverlay.classList.add('hidden');
            }
            
            allElements.loadingOverlay.addEventListener('click', initialize, { once: true });
        });
    </script>
</body>
</html>
